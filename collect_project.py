#!/usr/bin/env python3
"""
Collects the structure and contents of all Python (.py) files in a project
into a single, human- and machine-readable text file.

Output format:
1. Project tree (ASCII, directories containing .py files only, unless --include-empty-dirs)
2. Each .py file: relative path + contents, wrapped in clear delimiters:

---
FILE: path/to/file.py
<file content>
---
END FILE
---

Usage:
    python collect_project.py [--output OUTPUT] [--include-empty-dirs]

Defaults:
    --output project_analysis.txt
    Skips empty directories and standard ignored folders.

Ignored directories (case-insensitive):
    __pycache__, node_modules, .git, .idea, .vscode,
    .env, __macosx, venv, dist, build, .pytest_cache
"""

import sys
import argparse
from pathlib import Path

# Directories to ignore entirely (case-insensitive match)
IGNORE_DIRS = {
    '__pycache__', 'node_modules', '.git', '.idea', '.vscode',
    '.env', '__macosx', 'venv', 'dist', 'build', '.pytest_cache'
}


def should_ignore_dir(name: str) -> bool:
    """Check if directory name should be ignored."""
    return name.lower() in IGNORE_DIRS


def build_tree(root: Path, include_empty: bool = False, prefix: str = "", is_last: bool = True) -> str:
    """
    Build an ASCII tree representation of the project,
    showing only directories that contain .py files (unless include_empty=True)
    and all .py files.
    """
    lines = []
    try:
        entries = sorted([e for e in root.iterdir()], key=lambda x: (x.is_file(), x.name.lower()))
    except PermissionError:
        return prefix + "â”œâ”€â”€ [Permission Denied]\n"

    visible_entries = []
    for entry in entries:
        if entry.is_dir():
            if should_ignore_dir(entry.name):
                continue
            # Include directory if:
            # - include_empty=True, OR
            # - it (recursively) contains at least one .py file
            if include_empty or any(f.suffix.lower() == '.py' for f in entry.rglob('*') if f.is_file()):
                visible_entries.append(entry)
        elif entry.suffix.lower() == '.py':
            visible_entries.append(entry)

    for i, entry in enumerate(visible_entries):
        is_last_entry = (i == len(visible_entries) - 1)
        connector = "â””â”€â”€ " if is_last_entry else "â”œâ”€â”€ "
        line_prefix = prefix + connector

        if entry.is_dir():
            lines.append(line_prefix + entry.name + "/")
            extension = "    " if is_last_entry else "â”‚   "
            subtree = build_tree(entry, include_empty, prefix + extension, is_last_entry)
            if subtree:
                lines.append(subtree)
        else:
            lines.append(line_prefix + entry.name)

    return "\n".join(lines)


def collect_python_files(root: Path):
    """Yield (relative_path: Path, content: str) for each .py file."""
    for py_file in root.rglob("*.py"):
        # Skip if any parent directory is in IGNORE_DIRS
        if any(part.lower() in IGNORE_DIRS for part in py_file.relative_to(root).parts[:-1]):
            continue
        try:
            with open(py_file, 'r', encoding='utf-8') as f:
                content = f.read()
        except (UnicodeDecodeError, PermissionError, OSError) as e:
            print(f"[âš ï¸] Skipped: {py_file} ({e})", file=sys.stderr)
            continue
        yield py_file.relative_to(root), content


def main():
    parser = argparse.ArgumentParser(
        description="Collect project structure and Python source code into a single file.",
        epilog="Output is UTF-8 encoded, newline='\\n', ready for review or AI analysis."
    )
    parser.add_argument(
        "--output", "-o",
        type=Path,
        default="project_analysis.txt",
        help="Output file path (default: project_analysis.txt)"
    )
    parser.add_argument(
        "--include-empty-dirs",
        action="store_true",
        help="Include directories even if they contain no .py files"
    )
    args = parser.parse_args()

    root = Path.cwd()
    output_path = args.output

    print("ðŸ” Scanning project...")
    print("1. Building directory tree...")

    tree_str = build_tree(root, include_empty=args.include_empty_dirs)

    print("2. Collecting .py files...")
    collected = list(collect_python_files(root))
    print(f"   Found {len(collected)} .py file(s)")

    print("3. Writing to output file...")
    try:
        with open(output_path, "w", encoding="utf-8", newline="\n") as out:
            # Header
            out.write("# Project Structure & Source Code Dump\n")
            out.write("# Generated by collect_project.py\n")
            out.write(f"# Root: {root.resolve()}\n")
            out.write("# Format: tree + delimited file blocks\n\n")

            # Tree section
            out.write("## Project Tree (directories with .py files and .py files only)\n\n")
            if tree_str.strip():
                out.write("```\n")
                out.write(tree_str)
                out.write("\n```\n\n")
            else:
                out.write("> No .py files found.\n\n")

            # Files section
            out.write("## Collected Files\n\n")

            for i, (rel_path, content) in enumerate(collected, 1):
                out.write(f"---\nFILE: {rel_path}\n")
                out.write(content.rstrip("\n"))
                out.write("\n---\nEND FILE\n")
                if i < len(collected):
                    out.write("\n")

        print(f"âœ… Done! Output saved to: {output_path.resolve()}")
        print(f"ðŸ“Š Total files collected: {len(collected)}")

    except Exception as e:
        print(f"[âŒ] Write error: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()